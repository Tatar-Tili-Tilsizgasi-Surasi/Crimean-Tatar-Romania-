<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latin to Arabic Translit</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            background-color: #f4f4f4;
            color: #333;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            margin-bottom: 15px;
            padding: 12px;
            border: 1px solid #ccc;
            box-sizing: border-box; /* Include padding in width */
            font-size: 1.1em;
            border-radius: 4px;
            resize: vertical; /* Allow vertical resizing */
        }
        #arabicOutput {
            direction: rtl;
            text-align: right;
            font-family: "Traditional Arabic", "Arial", sans-serif; /* Use an Arabic-friendly font */
            background-color: #e9e9eb;
            border-color: #bbb;
        }
        button {
            display: block;
            width: 200px;
            margin: 15px auto;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
        }
         .rules {
             margin-top: 25px;
             padding: 15px;
             background-color: #fff;
             border: 1px solid #eee;
             border-radius: 5px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.05);
             /* Keep padding/styling even if content is removed */
             min-height: 20px; /* Give it some height even when empty */
             text-align: center; /* Center the remaining text */
         }
    </style>
</head>
<body>

    <h1>Latin to Arabic Transliteration</h1>

    <textarea id="latinInput" placeholder="Enter Latin text here..."></textarea>

    <button id="transliterateButton">Transliterate</button>

    <textarea id="arabicOutput" placeholder="Arabic output will appear here..." readonly></textarea>

    <div class="rules">
         <!-- Rule text removed as requested -->
         <p><i>Click "Transliterate" another one time to get different random variations for alternative spellings. 
But one problem is this two important rules are not included:

1— If ـّ fallows ـٍ it needs to be ا between them (e.g. hakkîñ = هَقّاٍ (or other alternatives, but not هَقٍّ).

2— One letter and Tanwin (ـٍ / ـً / ـٌ) is not allowed (e.g. men = مَنً (or other alternatives, but not مً).</i></p>
    </div>


    <script>
        document.getElementById('transliterateButton').addEventListener('click', transliterate);

        function transliterate() {
            const latinInput = document.getElementById('latinInput').value;
            const arabicOutput = document.getElementById('arabicOutput');

            console.log("Transliterate button clicked. Input:", latinInput);

            try {
                const result = performTransliteration(latinInput);
                arabicOutput.value = result;
                console.log("Transliteration successful. Output:", result);
            } catch (error) {
                console.error("An error occurred during transliteration:", error);
                arabicOutput.value = "Error during transliteration. Check console.";
            }
        }

        // Helper to check if a character is considered a Latin letter for word boundary checks
        function isLatinLetter(char) {
            if (char === null || char === undefined) return false;
             // This regex covers all listed Latin input characters used as letters
            return /[a-záéíóúñğçşîûüö]/i.test(char);
        }

         // Helper to check if a character is a consonant that can be geminated (used for the XX rule)
         function isPotentialGeminatingConsonant(char) {
             const geminatableConsonants = new Set([
                 'b', 'p', 't', 'ğ', 'ç', 'd', 'r', 'z', 'j', 's', 'ş',
                 'f', 'ñ', 'l', 'm', 'n', 'w', 'v', 'h', 'y', 'g', 'k'
             ]);
             return geminatableConsonants.has(char);
         }

         // Hard/Soft vowels for GK rule determination
         // á, ó, ú are now considered soft for GK rule
        const hardVowelRuleSet = new Set(['a', 'î', 'o', 'û']); // Removed ó, ú
        const softVowelRuleSet = new Set(['á', 'e', 'é', 'i', 'í', 'ö', 'ü', 'ó', 'ú']); // Added ó, ú


        // Helper for G/K rule lookup based on surrounding vowels
        function getArabicGK(latinChar, latinString, currentIndex, latinVowelSet, hardVowelSet, softVowelSet) {
             const isHardVowel = (vowel) => hardVowelSet.has(vowel);
             const isSoftVowel = (vowel) => softVowelSet.has(vowel);
             const char = latinString[currentIndex]; // already lowercased

             // Check adjacent vowels first, prioritizing preceding
             const prevInputChar = currentIndex > 0 ? latinString[currentIndex - 1] : null;
             const nextInputChar = currentIndex < latinString.length - 1 ? latinString[currentIndex + 1] : null;

             // Check immediately preceding vowel
             if (prevInputChar !== null && latinVowelSet.has(prevInputChar)) {
                console.log(`    GK rule: Found preceding vowel '${prevInputChar}'.`);
                 if (isSoftVowel(prevInputChar)) return (char === 'g' ? 'گ' : 'ك'); // Preceding Soft -> Soft GK
                 if (isHardVowel(prevInputChar)) return (char === 'g' ? 'غ' : 'ق'); // Preceding Hard -> Hard GK
             }

            // Check immediately following vowel
             if (nextInputChar !== null && latinVowelSet.has(nextInputChar)) {
                 console.log(`    GK rule: Found following vowel '${nextInputChar}'.`);
                 if (isSoftVowel(nextInputChar)) return (char === 'g' ? 'گ' : 'ك'); // Following Soft -> Soft GK
                 if (isHardVowel(nextInputChar)) return (char === 'g' ? 'غ' : 'ق'); // Following Hard -> Hard GK
             }

            // Search backwards for the last vowel
            let lastVowelBefore = null;
            for (let k = currentIndex - 1; k >= 0; k--) {
                if (latinVowelSet.has(latinString[k])) {
                    lastVowelBefore = latinString[k];
                    break;
                }
            }
            if (lastVowelBefore !== null) {
                 console.log(`    GK rule: Found last vowel before '${lastVowelBefore}'.`);
                 if (isSoftVowel(lastVowelBefore)) return (char === 'g' ? 'گ' : 'ك'); // Last Before Soft -> Soft GK
                 if (isHardVowel(lastVowelBefore)) return (char === 'g' ? 'غ' : 'ق'); // Last Before Hard -> Hard GK
            }

            // Search forwards for the first vowel
            let firstVowelAfter = null;
            for (let k = currentIndex + 1; k < latinString.length; k++) {
                 if (latinVowelSet.has(latinString[k])) {
                    firstVowelAfter = latinString[k];
                    break;
                }
            }
             if (firstVowelAfter !== null) {
                 console.log(`    GK rule: Found first vowel after '${firstVowelAfter}'.`);
                 if (isSoftVowel(firstVowelAfter)) return (char === 'g' ? 'گ' : 'ك'); // First After Soft -> Soft GK
                 if (isHardVowel(firstVowelAfter)) return (char === 'g' ? 'غ' : 'ق'); // First After Hard -> Hard GK
             }

            // Default soft (based on common Uyghur practice when no vowel context)
             console.log(`    GK rule: No determining vowel found. Defaulting to soft.`);
            return latinChar === 'g' ? 'گ' : 'ك';
        }

        // Define consonant mappings
        const consonantsBase = {
            'b': 'ب', 'p': 'پ', 't': 'ت', 'ğ': 'ج', 'ç': 'چ', 'd': 'د',
            'r': 'ر', 'z': 'ز', 'j': 'ژ', 's': 'س', 'ş': 'ش',
            'f': 'ف', 'ñ': 'ڭ', 'l': 'ل', 'm': 'م', 'n': 'ن',
            'h': 'ه',
            'w': 'و', // Waw can also be a vowel extender
            'y': 'ی', // Yeh can also be a vowel extender
            'v': 'و', // v maps to و
        };

        // Consonants that Sukun or final marks can attach to or consonants that can receive Sukun.
        // Include و and ی as consonants because they appear in consonantsBase.
        const allArabicConsonants = new Set([
            ...Object.values(consonantsBase),
            'گ', 'ك', 'غ', 'ق'
        ]);


        const latinVowels = new Set(['a', 'á', 'e', 'é', 'i', 'í', 'î', 'u', 'ú', 'û', 'o', 'ó', 'ö', 'ü']);

        // Pre-defined vowel sequences
        // Note: 'iy' will have a random alternative now, handled in transliterateWord
        const latinVowelSequences = new Set([
             'aa', 'ee',     // -> َآ
             'aá', 'áa', 'áá', // -> َا
             'ii',           // -> ِىٓ
             'oo', 'uw', 'úw', // -> ُو
             // 'iy' handled separately for randomization
        ]);

        // Mappings for standard short vowel diacritics
        const vowelsShortDiacritic = {
            'a': 'َ', 'á': 'َ', 'e': 'َ', 'é': 'َ', // Fatha
            'i': 'ِ', 'í': 'ِ', 'î': 'ِ', // Kasra
            'u': 'ُ', 'ú': 'ُ', 'û': 'ُ', 'o': 'ُ', 'ó': 'ُ', 'ö': 'ُ', 'ü': 'ُ' // Damma
        };

        // Mappings for alternative/decoration marks
         const alternativeMarks = {
             'alt_i': 'ٖ', // Alternative for middle/end i/í/î
             'alt_iy': 'ٖی', // Alternative for iy sequence
             'tanwin_a': 'ً', // Tanwin for a/e/é/á vowels ending in n/ñ
             'tanwin_u': 'ٌ', // Tanwin for u/o/ö/ü/ú/ó vowels ending in n/ñ
             'tanwin_i': 'ٍ'  // Tanwin for i/í/î vowels ending in n/ñ
        };

         // Map Latin vowel chars to types for the Tanwin rules (Rule 2 internal and Final Tanwin)
          const latinVowelToTypeForTanwin = {
            'a': 'a_like', 'á': 'a_like', 'e': 'a_like', 'é': 'a_like', // a, á, e, é -> ً
            'u': 'u_like', 'ú': 'u_like', 'û': 'u_like', 'o': 'u_like', 'ó': 'u_like', 'ö': 'u_like', 'ü': 'u_like', // u, ú, û, o, ó, ö, ü -> ٌ (Grouped loosely by sound)
            'i': 'i_like', 'í': 'i_like', 'î': 'i_like', // i, í, î -> ٍ
         };
         // Map these types to Tanwin alternatives
          const tanwinMap = {
              'a_like': alternativeMarks['tanwin_a'], // ً
              'u_like': alternativeMarks['tanwin_u'], // ٌ
              'i_like': alternativeMarks['tanwin_i'] // ٍ
          };


          // Alternative marks for the 'a'/'á' decoration rule (Applied during standard vowel handling, NOT initial)
          const aDecorationAlternativesForA = ['َ', 'َا', 'َو', 'َی', 'ٰ', 'ٰا', 'ٰو', 'ٰی']; // 8 options for 'a'
          const aDecorationAlternativesForÁ = ['َ', 'َا', 'ٰ', 'ٰا']; // 4 options for 'á'


        // Punctuation symbols
        const punctuationSymbolsSet = new Set(['!', '.', ',', '?', ';', '"', ':', '-']);

        // Symbol map *excluding* the single quote, which is now ignored
        const symbolMap = {
            '!': '؞', '.': '۔', ',': '،', '?': '؟', ';': '؛', ':': ':',
            '"': 'ۧ', '-': '؍', '(': '؍', ')': '؍', '%': '٪',
            // Removed "'": 'ء'
             ' ': ' ' // Include space for splitting
        };

        const digitMap = {
            '0': '٠', '1': '١', '2': '٢', '3': '٣', '4': '٤',
            '5': '٥', '6': '٦', '7': '٧', '8': '٨', '9': '٩'
        };

        // Separator characters (based on symbolMap, digitMap, and anything not a Latin letter)
        // Exclude the single quote as it is ignored
        const separatorChars = new Set([...Object.keys(symbolMap), ...Object.keys(digitMap)]);


        // Characters/Sequences/Marks that prevent Sukūn/Alternative on the *preceding* consonant or block diacritic attachment
        // Includes standard diacritics, alternative 'i', Tanwins (both types), Shadda, Madda, and vowel extenders/sequences + intermediate Sukun itself
        // Updated to include new alternatives for 'a'/'á' and 'iy'.
         const isPreventingMarkOrExtender = (c) => c && (['ا', 'و', 'ی', 'ّ', 'ٓ', 'َآ', 'ِىٓ', 'ُو', 'َا', 'ِی', 'ٰ', 'ٖ', 'ً', 'ٌ', 'ٍ', 'َو', 'َی', 'ٰا', 'ٰو', 'ٰی', 'ٖی', 'َ', 'ِ', 'ُ', 'ْ'].includes(c) || (c && /[\u064B-\u065F\u0670-\u067F\u0610-\u061A]/.test(c)));


        // Helper to find the last attachable point for diacritics/marks *within a segment*
        // Returns index or -1 (not found) or -2 (blocked)
        // Attachable to: base consonants, initial ا, Shadda ّ
        // Blocking: any existing mark/diacritic (except ّ), or sequence characters (ا, و, ی etc. unless they are the consonant base)
        function findLastDiacriticAttachPointIndex(arr) {
             for(let k = arr.length - 1; k >= 0; k--) {
                 const c = arr[k];
                 // Is it attachable? (Consonant, initial ا, or Shadda)
                 const isAttachable = allArabicConsonants.has(c) || c === 'ا' || c === 'ّ';
                 if (isAttachable) {
                     return k;
                 }
                 // Is it blocking? (Any other mark, vowel extender, or sequence part)
                  const isBlocking = isPreventingMarkOrExtender(c);
                  if(isBlocking && c !== 'ّ') { // Shadda is the only 'preventing' mark we *can't* attach *after* a blocking mark
                     return -2; // Indicate blocked search
                  }
             }
             return -1; // Not found
        }

        // Helper to check if a character blocks insertion of a diacritic/mark *at* its position *within a segment*
        // This is the same as checking if the character itself is a preventing mark/extender, excluding Shadda
        function isBlockingInsertion(char) {
             return isPreventingMarkOrExtender(char) && char !== 'ّ';
        }


        // Helper to split Latin input into words and separators
        function splitIntoWordsAndSeparators(latin) {
            const segments = [];
            let currentWord = '';
            for (let i = 0; i < latin.length; i++) {
                const char = latin[i]; // Keep original case for separators like ? ! etc.
                const lowerChar = char.toLowerCase();

                // Check if the character should be ignored (currently only single quote)
                if (char === "'") {
                    console.log(`  Ignoring character: '${char}'`);
                    continue; // Skip this character entirely
                }


                const isSeparator = separatorChars.has(char) || separatorChars.has(lowerChar) || !isLatinLetter(lowerChar); // Check both cases for separators

                if (isSeparator) {
                    // If we were building a word, add it
                    if (currentWord !== '') {
                        segments.push(currentWord);
                        currentWord = '';
                    }
                    // Add the separator itself
                    segments.push(char); // Add the original character

                } else {
                    // It's a letter, add to current word (lowercase)
                    currentWord += lowerChar;
                }
            }
            // Add any remaining word at the end
            if (currentWord !== '') {
                segments.push(currentWord);
            }
            console.log("Split input into segments:", segments);
            return segments;
        }


        // Helper to transliterate a single Latin word into Arabic characters, including intermediate Sukuns and internal alternatives.
        // Final mark (Sukun or END-OF-WORD Tanwin alternative) is *not* applied here.
        // Returns { arabicChars: Array, lastSimpleVowelLatinChar: String }
        function transliterateWord(latinWord) {
             console.log(`Transliterating word: '${latinWord}'`);
            let arabicWordChars = [];
            let lastSimpleVowelLatinChar = null; // Track the Latin vowel character for the last simple vowel attached to a base

            let i = 0;

            while (i < latinWord.length) {
                const char = latinWord[i]; // Already lowercased by split function
                const nextChar = latinWord[i + 1];
                const nextTwoChars = latinWord.substring(i, i + 2);
                const prevLatin = i > 0 ? latinWord[i - 1] : null;

                console.log(`  Word Index ${i}, Char: '${char}', NextTwo: '${nextTwoChars}', PrevLatin: '${prevLatin}', Arabic array size: ${arabicWordChars.length}, Array: ${arabicWordChars.join('')}, LastSimpleVowelLatinChar: ${lastSimpleVowelLatinChar}`);


                // --- Rule Priority within a word ---

                 // Check if it's the very first character of the word and it's a vowel
                 const isInitialVowel = (i === 0 && latinVowels.has(char));
                 if (isInitialVowel) {
                     console.log(`  (Special Initial Vowel) Processing initial vowel: ${char} at index ${i}`);
                     const initialBase = Math.random() < 0.5 ? 'ا' : 'ء'; // Randomly choose initial base
                     let markToAttach = vowelsShortDiacritic[char]; // Use standard mapping for initial vowels

                     // Ensure standard marks for a/á and i/í/î at the beginning
                     if (char === 'a' || char === 'á') {
                          markToAttach = 'َ'; // Always standard Fatha at the start for a/á
                          console.log(`  Forcing standard Fatha ('َ') for initial vowel '${char}'.`);
                      } else if (char === 'i' || char === 'í' || char === 'î') {
                           markToAttach = 'ِ'; // Always standard Kasra at the start for i/í/î
                           console.log(`  Forcing standard Kasra ('ِ') for initial vowel '${char}'.`);
                      } else {
                           // Other vowels (e,é,u,ú,û,o,ó,ö,ü) use their standard initial mapping (usually َ or ُ)
                            console.log(`  Using standard initial mark '${markToAttach}' for vowel '${char}'.`);
                      }


                     arabicWordChars.push(initialBase); // Add the base (ا or ء)
                     if (markToAttach) {
                          arabicWordChars.push(markToAttach); // Add the standard diacritic mark
                           console.log(`  Added initial vowel representation '${initialBase}${markToAttach}'. Array: ${arabicWordChars.join('')}`);
                     } else {
                          console.warn(`  Initial vowel '${char}' has no standard mapped diacritic. Added base '${initialBase}' only.`);
                     }

                     lastSimpleVowelLatinChar = char; // Track the Latin char
                     console.log(`  Updated lastSimpleVowelLatinChar to ${lastSimpleVowelLatinChar} after initial vowel.`);

                     i++; // Processed the single initial vowel Latin char
                     continue; // Move to next Latin char
                 }


                // 1. Handle Specific Multi-Character Sequences (Gemination, Vowel Sequences, iy)
                // Gemination check (already covers 2 chars)
                 const isPotentialGeminatingConsonantAtI = isPotentialGeminatingConsonant(char);
                 if (isPotentialGeminatingConsonantAtI && char === nextChar && i + 1 < latinWord.length) {
                      console.log(`  (Rule 1.1) Detected potential gemination: ${char}${char} at index ${i}`);
                      let arabicConsonantForGemination;
                      if (char === 'g' || char === 'k') { arabicConsonantForGemination = getArabicGK(char, latinWord, i, latinVowels, hardVowelRuleSet, softVowelRuleSet); }
                      else { arabicConsonantForGemination = consonantsBase[char]; }
                      if (arabicConsonantForGemination) {
                            arabicWordChars.push(arabicConsonantForGemination); arabicWordChars.push('ّ');
                            i += 2; lastSimpleVowelLatinChar = null; console.log("  Handled gemination. Reset vowel tracking."); continue;
                       } else { console.warn(`  Gemination '${char}${char}' found, but no Arabic consonant mapping for '${char}'. Treating as single chars.`); } // Fall through
                 }

                 // Vowel Sequences check (aa, ee, aá, áa, áá, ii, oo, uw,úw)
                 if (i + 1 < latinWord.length && latinVowelSequences.has(nextTwoChars)) {
                      console.log(`  (Rule 1.2a) Processing sequence: ${nextTwoChars} at index ${i}`);
                      let sequenceArabic = null;
                      if (nextTwoChars === 'aa' || nextTwoChars === 'ee') sequenceArabic = 'َآ';
                      else if (nextTwoChars === 'aá' || nextTwoChars === 'áa' || nextTwoChars === 'áá') sequenceArabic = 'َا';
                      else if (nextTwoChars === 'ii') sequenceArabic = 'ِىٓ';
                      else if (nextTwoChars === 'oo' || nextTwoChars === 'uw' || nextTwoChars === 'úw') sequenceArabic = 'ُو';

                      if (sequenceArabic) {
                          arabicWordChars.push(sequenceArabic);
                          i += 2; lastSimpleVowelLatinChar = null; console.log(`  Handled sequence '${nextTwoChars}'. Reset tracking.`); continue;
                      }
                 }

                 // 'iy' sequence check with randomization
                  if (nextTwoChars === 'iy') {
                      console.log(`  (Rule 1.2b) Processing 'iy' sequence at index ${i}`);
                      const chosenAlternative = Math.random() < 0.5 ? 'ِی' : alternativeMarks['alt_iy']; // 50% chance for ٖی
                      arabicWordChars.push(chosenAlternative);
                      i += 2;
                      lastSimpleVowelLatinChar = null; // Sequences reset vowel tracking
                      console.log(`  Handled 'iy', added '${chosenAlternative}'. Array: ${arabicWordChars.join('')}. Reset tracking.`);
                      continue;
                  }


                // 2. Handle VOWEL + N/Ñ pair (Tanwin Alternative or Standard C+N+Sukun)
                 const isPotentialVowelNNPair = latinVowels.has(char) && (nextChar === 'n' || nextChar === 'ñ') && (i + 1 < latinWord.length);
                 // This rule applies to V+N/Ñ pairs *not* at the very start (i > 0) AND not followed by another vowel
                 if (isPotentialVowelNNPair && i > 0) {
                     console.log(`  (Rule 2) Detected potential Vowel+N/Ñ pair: ${char}${nextChar} at index ${i}.`);
                     const nextNextChar = latinWord[i + 2];
                     const isFollowedByVowel = (i + 2 < latinWord.length) && latinVowels.has(nextNextChar);

                     // This pair is eligible for the internal Tanwin alternative IF NOT followed by a vowel
                     if (!isFollowedByVowel) {
                         console.log(`  Pair ${char}${nextChar} is eligible for internal Tanwin alternative.`);
                         const useTanwinAlternative = Math.random() < 0.5; // 50% chance

                         if (useTanwinAlternative) {
                             console.log(`  Randomly chose Tanwin alternative.`);
                             // Determine Tanwin mark based on the vowel character
                             const tanwinType = latinVowelToTypeForTanwin[char];
                             const tanwinMark = tanwinMap[tanwinType]; // e.g., 'ً', 'ٌ', 'ٍ'

                             if (tanwinMark) {
                                  arabicWordChars.push(tanwinMark);
                                  console.log(`  Added internal Tanwin mark '${tanwinMark}'. Array: ${arabicWordChars.join('')}`);
                                  lastSimpleVowelLatinChar = null; // Tanwin replaces vowel + consonant info
                                  console.log("  Reset lastSimpleVowelLatinChar after internal Tanwin.");
                             } else {
                                 console.warn(`  Vowel '${char}' has no mapped Tanwin type for alternative. Falling back to standard CVn.`);
                                 // Fallback to standard if Tanwin map fails for this vowel type (shouldn't happen with current maps)
                                 // Process as Standard CVn below - always standard vowel mark here
                                  let standardVowelMark = vowelsShortDiacritic[char];
                                  if ((char === 'i' || char === 'í' || char === 'î') && standardVowelMark === 'ِ') { standardVowelMark = Math.random() < 0.5 ? alternativeMarks['alt_i'] : 'ِ'; console.log(`  Randomly chose alternative mark '${standardVowelMark}' for '${char}' (V+N/Ñ Tanwin fallback).`);} // 50% chance for ٖ

                                  // IMPORTANT: For the Vowel+N/Ñ fallback to standard CVn, DO NOT apply the 'a'/'á' randomization here.
                                  // Those alternatives like َا, َو, َی, ٰ, ٰا, ٰو, ٰی are specific to vowel marks *not* followed immediately by the 'ن' or 'ڭ' consonant.
                                  // Standard CVn mapping is VowelMark + Consonant + Sukun. The VowelMark here should be standard َ or ِ or ُ.

                                 if (standardVowelMark) arabicWordChars.push(standardVowelMark);
                                 const arabicConsonant = consonantsBase[nextChar]; // 'n' or 'ñ' -> 'ن' or 'ڭ'
                                 arabicWordChars.push(arabicConsonant);
                                 arabicWordChars.push('ْ'); // Add Sukun
                                 lastSimpleVowelLatinChar = char; // Keep vowel info for potential END-OF-WORD Tanwin later
                                 console.log(`  Added standard representation (fallback) '${standardVowelMark || ''}${arabicConsonant}ْ'. Array: ${arabicWordChars.join('')}`);
                             }
                             i += 2; // Processed both Latin chars (Vowel + N/Ñ)
                             continue; // Move to next Latin char index i+2

                         } else { // Randomly chose standard representation (50% chance)
                             console.log(`  Randomly chose standard Vowel+N/Ñ representation. Processing as Standard CVn.`);
                             // Process as Standard CVn below - always standard vowel mark here
                              let standardVowelMark = vowelsShortDiacritic[char];
                              if ((char === 'i' || char === 'í' || char === 'î') && standardVowelMark === 'ِ') { standardVowelMark = Math.random() < 0.5 ? alternativeMarks['alt_i'] : 'ِ'; console.log(`  Randomly chose alternative mark '${standardVowelMark}' for '${char}' (V+N/Ñ standard).`);} // 50% chance for ٖ

                              // IMPORTANT: Again, for the Vowel+N/Ñ standard CVn path, DO NOT apply the 'a'/'á' randomization here.
                              // Those alternatives are not used in the V + C + Sukun pattern.

                              if (standardVowelMark) arabicWordChars.push(standardVowelMark);
                              const arabicConsonant = consonantsBase[nextChar]; // 'n' or 'ñ' -> 'ن' or 'ڭ'
                              arabicWordChars.push(arabicConsonant);
                              arabicWordChars.push('ْ'); // Add Sukun
                              lastSimpleVowelLatinChar = char; // Keep vowel info for potential END-OF-WORD Tanwin later
                             console.log(`  Added standard representation '${standardVowelMark || ''}${arabicConsonant}ْ'. Array: ${arabicWordChars.join('')}`);

                             i += 2; // Processed both Latin chars (Vowel + N/Ñ)
                             continue; // Move to next Latin char index i+2
                         }
                     } else if (isPotentialVowelNNPair && i === 0) { // *** ADDED CASE: Vowel+N/Ñ at the beginning ***
                           console.log(`  Pair ${char}${nextChar} is at the start (i=0). Internal Tanwin alternative skipped. Forcing standard CVn.`);
                           // Always force standard CVn representation at the start
                           let standardVowelMark = vowelsShortDiacritic[char];
                            // Apply initial vowel restrictions for the mark itself (already handled in the Initial Vowel block, but repeat for clarity/safety)
                           if (char === 'a' || char === 'á') { standardVowelMark = 'َ'; }
                           else if (char === 'i' || char === 'í' || char === 'î') { standardVowelMark = 'ِ'; }
                           // For other vowels (e,é,u,etc), standardVowelMark is already correct (َ or ُ)

                           // Add the initial base (ا or ء) followed by the standard mark
                           const initialBase = Math.random() < 0.5 ? 'ا' : 'ء';
                           arabicWordChars.push(initialBase);
                           if (standardVowelMark) {
                               arabicWordChars.push(standardVowelMark);
                           } else {
                                console.warn(`  Initial V+N/Ñ vowel '${char}' has no standard mapped diacritic. Added base '${initialBase}' only.`);
                           }

                           // Then add the N/Ñ consonant and Sukun
                           const arabicConsonant = consonantsBase[nextChar]; // 'n' or 'ñ' -> 'ن' or 'ڭ'
                           arabicWordChars.push(arabicConsonant);
                           arabicWordChars.push('ْ'); // Add Sukun

                           lastSimpleVowelLatinChar = char; // Keep vowel info for potential END-OF-WORD Tanwin later
                           console.log(`  Added initial V+N/Ñ representation (forced standard) '${initialBase}${standardVowelMark || ''}${arabicConsonant}ْ'. Array: ${arabicWordChars.join('')}`);

                           i += 2; // Processed both Latin chars (Vowel + N/Ñ)
                           continue; // Move to next Latin char index i+2

                     } else { // isPotentialVowelNNPair is false or isFollowedByVowel is true (and not i===0)
                          // Fall through to other rules
                         if (isPotentialVowelNNPair && isFollowedByVowel) { console.log(`  Pair ${char}${nextChar} is followed by vowel. Not eligible for internal Tanwin alternative. Falling through to standard vowel/consonant handling.`); }
                          // If not a Vowel+N/Ñ pair or if it's Vowel+N/Ñ followed by vowel, it will be handled by Rule 3 (Vowel) then Rule 4 (Consonant).
                     }
                } // End Rule 2 (VOWEL + N/Ñ pair)


                // 3. Handle Single Vowels (Applies if not part of Sequence or Vowel+N/Ñ pair that was handled by 'continue')
                // This rule is now for vowels *after* the first character.
                const isCurrentCharVowel = latinVowels.has(char);
                 if (isCurrentCharVowel) {
                      console.log(`  (Rule 3) Processing single vowel (not initial): ${char} at index ${i}`);
                      let addedSpecialCase = false; // Flag for specific vowel handling paths within this block

                      // --- ّ+ا+ِ Rule: If Shadda (ّ) is followed by Kasra (ِ), insert Alef (ا) ---
                     if ( (char === 'i' || char === 'í' || char === 'î') && arabicWordChars.length > 0 && arabicWordChars[arabicWordChars.length - 1] === 'ّ') {
                         console.log(`  Detected potential ّ+ِ -> ّ+ا+ِ rule trigger with '${char}' at Latin index ${i}. Applying rule.`);
                         arabicWordChars.splice(arabicWordChars.length, 0, 'ا', 'ِ'); // Insert 'ا' then 'ِ'
                         addedSpecialCase = true;
                         lastSimpleVowelLatinChar = char; console.log(`  Applied rule, inserted 'ا' and 'ِ'. Array: ${arabicWordChars.join('')}. Updated lastSimpleVowelLatinChar to ${lastSimpleVowelLatinChar}.`);
                     }
                    // --- End of ّ+ا+ِ Rule ---

                    // --- Vowel After Extender Sequence Handling (ُوِ, ِیَ etc.) ---
                    // Apply 'a'/'á' randomization here (not initial vowel)
                    if (!addedSpecialCase) {
                         // Also include the new 'a'/'á' and 'iy' alternatives as potential sequence endings
                         const endOfArabic = arabicWordChars.join(''); const sequenceEndings = ['َآ', 'ِىٓ', 'ُو', 'َا', 'ِی', 'ٰ', 'ٖ', 'َو', 'َی', 'ٰا', 'ٰو', 'ٰی', 'ٖی'];
                         let sequenceMatchedEnding = null;
                         for(const seq of sequenceEndings) { if (endOfArabic.endsWith(seq)) { sequenceMatchedEnding = seq; break; } }

                        if (sequenceMatchedEnding) {
                            console.log(`  Current vowel '${char}' at Latin index ${i} follows an Arabic sequence ending ('${sequenceMatchedEnding}').`);
                            let markToAttach = vowelsShortDiacritic[char];

                             // --- Apply Randomization for 'a' or 'á' after Sequence ---
                             if (char === 'a') { const alternatives = aDecorationAlternativesForA; const numAlternatives = alternatives.length; const randomChoice = Math.random(); const step = 1 / numAlternatives; let chosenAlternative = alternatives[0]; for (let k = 0; k < numAlternatives; k++) { if (randomChoice < step * (k + 1)) { chosenAlternative = alternatives[k]; break; } } markToAttach = chosenAlternative; console.log(`  Randomly chose mark alternative '${markToAttach}' for '${char}' after sequence.`); }
                             else if (char === 'á') { const alternatives = aDecorationAlternativesForÁ; const numAlternatives = alternatives.length; const randomChoice = Math.random(); const step = 1 / numAlternatives; let chosenAlternative = alternatives[0]; for (let k = 0; k < numAlternatives; k++) { if (randomChoice < step * (k + 1)) { chosenAlternative = alternatives[k]; break; } } markToAttach = chosenAlternative; console.log(`  Randomly chose mark alternative '${markToAttach}' for '${char}' after sequence.`); }
                              // --- End Randomization for 'a'/'á' ---

                           // --- Apply Randomization for i/í/î after Sequence ---
                            if ((char === 'i' || char === 'í' || char === 'î') && markToAttach === 'ِ') {
                                 if (Math.random() < 0.5) {
                                     markToAttach = alternativeMarks['alt_i']; // Use ٖ 50% of the time
                                     console.log(`  Randomly chose alternative mark '${markToAttach}' for '${char}' after sequence.`);
                                 } else {
                                      console.log(`  Randomly chose standard mark '${markToAttach}' for '${char}' after sequence.`);
                                 }
                            }
                           // --- End Randomization for i/í/î ---

                            if (markToAttach) { arabicWordChars.push(markToAttach); console.log(`  Attached mark '${markToAttach}' after sequence ending. Array: ${arabicWordChars.join('')}`); addedSpecialCase = true; lastSimpleVowelLatinChar = char; console.log(`  Updated lastSimpleVowelLatinChar to ${lastSimpleVowelLatinChar}.`); }
                            else { console.warn(`  Vowel '${char}' after sequence ending has no mapped diacritic. Skipping attachment.`); lastSimpleVowelLatinChar = null; console.log("  Reset vowel tracking after skipped attachment."); addedSpecialCase = true; }
                        }
                    }
                    // --- End Vowel After Extender Sequence Handling ---

                    // --- Vowel After Vowel ('ا' Insertion) Handling ---
                     // Apply 'a'/'á' randomization here (not initial vowel)
                     // Also handle vowels after a V+N/Ñ sequence that was NOT turned into an internal Tanwin (e.g. in 'barganda', the 'a' after 'n')
                    if (!addedSpecialCase && prevLatin !== null && (latinVowels.has(prevLatin) || (prevLatin === 'n' || prevLatin === 'ñ')) && !latinVowelSequences.has(prevLatin + char) && nextTwoChars !== 'iy') { // Exclude 'iy' as it's handled as a sequence
                         console.log(`  Current vowel '${char}' follows previous Latin vowel/non-tanwin N/Ñ '${prevLatin}'. Pair '${prevLatin + char}' is not a predefined sequence (excluding iy). Inserting 'ا'.`);
                         // Insert 'ا' after the last sequence part, or after the consonant from Rule 2 fallback/standard
                         const insertIndexForAlef = arabicWordChars.length;
                          // If the *immediately* preceding char in arabicWordChars is a consonant that came from the prevLatin N/Ñ,
                          // insert 'ا' *after* that consonant + its sukun, effectively after the C+Sukun cluster.
                          // Otherwise, insert at the end.
                           let actualInsertIndexForAlef = arabicWordChars.length;
                           // Check if the last few chars are Consonant + Sukun (from Rule 2 fallback/standard)
                           if (arabicWordChars.length >= 2 && arabicWordChars[arabicWordChars.length - 1] === 'ْ' && allArabicConsonants.has(arabicWordChars[arabicWordChars.length - 2])) {
                                actualInsertIndexForAlef = arabicWordChars.length; // Insert after the Sukun
                           } else {
                                // If the previous char was a vowel extender (ا, و, ی) or mark (َ, ِ, ُ, etc.), we might need to insert AFTER it.
                                // This is complex; for simplicity and correctness based on the rule structure,
                                // inserting 'ا' always at the end *unless* after a specific sequence ending is safer.
                                // Let's revert to simpler: insert 'ا' always at the end of the current arabicWordChars array
                                // if not following a *predefined* sequence ending.
                                // The previous rule (Vowel After Extender Sequence) handles cases where it *should* attach to the end of a sequence.
                                // This rule (Vowel After Vowel) implies inserting 'ا'.
                                // Let's re-evaluate: "bui -> بُاِ". The 'u' gives بُ, then 'i' gives اِ. The اِ attaches to the end.
                                // "barganda", 'n' is not followed by vowel, gets ْ. بَارْغَانْ + دَا. The 'a' after 'n' triggers Vowel After Vowel.
                                // The preceding Latin was 'n'. Its Arabic mapping was َن. No, َن is for vowel 'a'. 'n' -> نْ.
                                // So the previous character processed was 'n', which resulted in نْ being added.
                                // Current char 'a' after this 'n'. Rule: Vowel after Consonant? No, previous Latin was consonant 'n'.
                                // Rule: Vowel after Vowel? Yes, if considering syllable structure abstractly.
                                // Let's stick to the simpler logic: Vowel after Latin Vowel -> insert ا. Vowel after Latin Consonant -> attach mark to consonant.
                                // The Vowel After Vowel logic should *only* trigger if prevLatin was a vowel and the pair isn't a sequence.

                                // Let's refine the Vowel After Vowel logic check:
                                // Trigger only if prevLatin IS a vowel:
                                if (prevLatin !== null && latinVowels.has(prevLatin) && !latinVowelSequences.has(prevLatin + char) && nextTwoChars !== 'iy') {
                                    console.log(`  (Rule 3 - Vowel After Vowel) Current vowel '${char}' follows previous Latin vowel '${prevLatin}'. Pair '${prevLatin + char}' is not a predefined sequence (excluding iy). Inserting 'ا'.`);
                                     arabicWordChars.splice(arabicWordChars.length, 0, 'ا'); // Insert 'ا' at the end
                                     const alefIndex = arabicWordChars.length - 1; // Index of the inserted 'ا'
                                     console.log(`  Inserted 'ا' at index ${alefIndex}. Array: ${arabicWordChars.join('')}`);
                                     let markToAttach = vowelsShortDiacritic[char];
                                      // Apply randomization for 'a' or 'á'
                                      if (char === 'a') { const alternatives = aDecorationAlternativesForA; const numAlternatives = alternatives.length; const randomChoice = Math.random(); const step = 1 / numAlternatives; let chosenAlternative = alternatives[0]; for (let k = 0; k < numAlternatives; k++) { if (randomChoice < step * (k + 1)) { chosenAlternative = alternatives[k]; break; } } markToAttach = chosenAlternative; console.log(`  Randomly chose mark alternative '${markToAttach}' for '${char}' after 'ا'.`); }
                                      else if (char === 'á') { const alternatives = aDecorationAlternativesForÁ; const numAlternatives = alternatives.length; const randomChoice = Math.random(); const step = 1 / numAlternatives; let chosenAlternative = alternatives[0]; for (let k = 0; k < numAlternatives; k++) { if (randomChoice < step * (k + 1)) { chosenAlternative = alternatives[k]; break; } } markToAttach = chosenAlternative; console.log(`  Randomly chose mark alternative '${markToAttach}' for '${char}' after 'ا'.`); }
                                       // Apply randomization for i/í/î
                                       if ((char === 'i' || char === 'í' || char === 'î') && markToAttach === 'ِ') { if (Math.random() < 0.5) { markToAttach = alternativeMarks['alt_i']; console.log(`  Randomly chose alternative mark '${markToAttach}' for '${char}' after 'ا'.`); } else { console.log(`  Randomly chose standard mark '${markToAttach}' for '${char}' after 'ا'.`); } }

                                     if (markToAttach) { arabicWordChars.splice(alefIndex + 1, 0, markToAttach); console.log(`  Attached mark '${markToAttach}' to 'ا'. Array: ${arabicWordChars.join('')}`); lastSimpleVowelLatinChar = char; console.log(`  Updated lastSimpleVowelLatinChar to ${lastSimpleVowelLatinChar}.`); }
                                     else { console.warn(`  Vowel '${char}' after 'ا' has no mapped diacritic. Skipping attachment.`); lastSimpleVowelLatinChar = null; console.log("  Reset vowel tracking after skipped attachment."); }
                                     addedSpecialCase = true;
                                } // End of actual Vowel After Vowel check logic
                           }
                    }
                    // --- End Vowel After Vowel Handling ---

                   // --- Standard Single Vowel Handling (Applies only if not handled by special cases like initial or sequences) ---
                   // This path is for vowels after consonants or sequence characters that don't form the "vowel after extender" pattern.
                   if (!addedSpecialCase) {
                       console.log(`  Handling standard single vowel '${char}' after consonant or non-extender sequence.`);
                       let attachIndex = findLastDiacriticAttachPointIndex(arabicWordChars);
                        if (attachIndex === -2) { console.warn(`  Diacritic/Mark attachment blocked before finding point for vowel '${char}'. Skipping.`); lastSimpleVowelLatinChar = null; console.log("  Reset vowel tracking."); }
                        else if (attachIndex >= 0) {
                            const insertIndex = attachIndex + 1;
                            if (insertIndex < arabicWordChars.length && isBlockingInsertion(arabicWordChars[insertIndex])) { console.warn(`  Attempted to insert mark/diacritic at index ${insertIndex} for vowel '${char}' but found existing mark '${arabicWordChars[insertIndex]}'. Skipping insertion.`); lastSimpleVowelLatinChar = null; console.log("  Reset vowel tracking."); }
                            else {
                                let markToAttach = vowelsShortDiacritic[char];
                                 // --- Apply Randomization for 'a' or 'á' ---
                                 if (char === 'a') { const alternatives = aDecorationAlternativesForA; const numAlternatives = alternatives.length; const randomChoice = Math.random(); const step = 1 / numAlternatives; let chosenAlternative = alternatives[0]; for (let k = 0; k < numAlternatives; k++) { if (randomChoice < step * (k + 1)) { chosenAlternative = alternatives[k]; break; } } markToAttach = chosenAlternative; console.log(`  Randomly chose standard mark alternative '${markToAttach}' for '${char}'.`); }
                                else if (char === 'á') { const alternatives = aDecorationAlternativesForÁ; const numAlternatives = alternatives.length; const randomChoice = Math.random(); const step = 1 / numAlternatives; let chosenAlternative = alternatives[0]; for (let k = 0; k < numAlternatives; k++) { if (randomChoice < step * (k + 1)) { chosenAlternative = alternatives[k]; break; } } markToAttach = chosenAlternative; console.log(`  Randomly chose standard mark alternative '${markToAttach}' for '${char}'.`); }
                                 // --- End Randomization for 'a'/'á' ---

                                 // --- Apply Randomization for i/í/î ---
                                 if ((char === 'i' || char === 'í' || char === 'î') && markToAttach === 'ِ') { if (Math.random() < 0.5) { markToAttach = alternativeMarks['alt_i']; console.log(`  Randomly chose alternative mark '${markToAttach}' for '${char}' (standard attach).`); } else { console.log(`  Randomly chose standard mark '${markToAttach}' for '${char}' (standard attach).`); } }
                                 // --- End Randomization for i/í/î ---

                                if (markToAttach) { arabicWordChars.splice(insertIndex, 0, markToAttach); console.log(`  Attached mark/diacritic '${markToAttach}' after index ${attachIndex}. Array: ${arabicWordChars.join('')}`); lastSimpleVowelLatinChar = char; console.log(`  Updated lastSimpleVowelLatinChar to ${lastSimpleVowelLatinChar}.`); }
                                else { console.warn(`  Vowel '${char}' after consonant/sequence has no mapped diacritic. Skipping.`); lastSimpleVowelLatinChar = null; console.log("  Reset vowel tracking."); }
                            }
                        } else { console.warn(`  Single vowel '${char}' after consonant/sequence, but no attachable Arabic character found for mark/diacritic. Skipping.`); lastSimpleVowelLatinChar = null; console.log("  Reset vowel tracking."); }
                   } // End Standard Single Vowel Handling

                     i++; // Increment after processing the single vowel
                     continue; // Move to next Latin char
                 } // End Rule 3 (Single Vowel)


                // 4. Handle Single Consonants (Applies if not part of Sequence or Vowel+N/Ñ pair that was handled by 'continue')
                let arabicConsonant = consonantsBase[char];

                // Handle g/k using the helper function BEFORE pushing the consonant
                if (char === 'g' || char === 'k') {
                    arabicConsonant = getArabicGK(char, latinWord, i, latinVowels, hardVowelRuleSet, softVowelRuleSet);
                    console.log(`  (Rule 4) Processed GK consonant '${char}' at index ${i}, mapped to '${arabicConsonant}'.`);
                } else if (arabicConsonant) {
                     console.log(`  (Rule 4) Processed base consonant '${char}' at index ${i}, mapped to '${arabicConsonant}'.`);
                }

                if (arabicConsonant) {
                    arabicWordChars.push(arabicConsonant);
                    console.log(`  Added consonant '${arabicConsonant}'. Array: ${arabicWordChars.join('')}`);

                    // --- Add Intermediate Sukun ---
                    // Add Sukun UNLESS it's the very last character of the word OR
                    // the next Latin character is a vowel (meaning its mark will follow)
                    // or it's the N/Ñ followed by a vowel in a CVnV sequence (handled by falling through Rule 2)
                    const isLastLatinChar = (i === latinWord.length - 1);
                    const nextLatinIsVowel = !isLastLatinChar && latinVowels.has(latinWord[i+1]);

                     if (!isLastLatinChar && !nextLatinIsVowel) {
                        // Next Latin is a consonant or there are no more Latin characters. Add Sukun.
                         arabicWordChars.push('ْ');
                         console.log(`  Added intermediate Sukun after '${arabicConsonant}' because next Latin char '${latinWord[i+1] || '[end]'}' is not a vowel.`);
                     } else { // isLastLatinChar is true OR nextLatinIsVowel is true (CVnV case, etc.)
                          console.log(`  Skipped intermediate Sukun after '${arabicConsonant}' because it is the last Latin character or next Latin is a vowel.`);
                     }
                    // --- End Add Intermediate Sukun ---

                    i++; // Increment after processing the single consonant
                    // Consonant processing doesn't change the preceding vowel's context for the end-of-word rule
                    // The lastSimpleVowelLatinChar refers to the vowel *before* this consonant.
                    continue; // Move to next Latin char
                }

                // 5. Add any other unmapped characters as is (Fallback)
                console.warn(`  (Rule 5) Processing unmapped letter '${char}' at index ${i} within word. Added as is.`);
                arabicWordChars.push(latinWord[i]);
                i++;
                lastSimpleVowelLatinChar = null; // Reset vowel tracking if an unexpected character appears
                console.log("  Reset vowel tracking due to unmapped letter.");
                continue; // Move to next Latin char
            } // End while loop through word

             console.log(`Finished transliterating word '${latinWord}'. Intermediate Arabic with intermediate Sukuns: ${arabicWordChars.join('')}, LastSimpleVowelLatinChar: ${lastSimpleVowelLatinChar}`);
            return { arabicChars: arabicWordChars, lastSimpleVowelLatinChar: lastSimpleVowelLatinChar };
        }


        // Helper to apply final mark (Sukūn or Tanwin alternative) to the last consonant if needed.
        // Intermediate Sukuns are already added by transliterateWord, but we might remove a trailing one.
        // needsTanwin is true if the word is the absolute last or followed by punctuation
        // Note: This applies the *end-of-word* Tanwin based on the *last simple vowel*. It's separate from the Vowel+N/Ñ internal Tanwin.
        function applyFinalMarkToLastConsonant(arabicWordChars, latinWord, lastSimpleVowelLatinChar, needsTanwin) {
             console.log(`Applying final mark to last consonant if needed for word '${latinWord}'. Needs Tanwin: ${needsTanwin}. Input Arabic chars (potentially with intermediate Sukuns and internal alternatives): ${arabicWordChars.join('')}, Last vowel Latin Char: ${lastSimpleVowelLatinChar}`);

            const resultChars = [...arabicWordChars]; // Clone the array to modify it
            const len = resultChars.length;


            // Find the index of the last character in the Arabic word that is a base consonant.
            // This is the consonant *after* which the final mark (Sukūn or END-OF-WORD Tanwin) should potentially be attached.
            // We need this index *before* removing any trailing Sukun.
            let lastConsonantIndex = -1;
            for (let k = len - 1; k >= 0; k--) {
                if (allArabicConsonants.has(resultChars[k])) {
                    lastConsonantIndex = k;
                    break;
                }
            }

            // If no consonant found, return as is.
            if (lastConsonantIndex === -1) {
                 console.log("  No consonant found. No final mark applied.");
                 return resultChars.join('');
            }

             const lastConsonant = resultChars[lastConsonantIndex];
             const charAfterLastConsonant = resultChars[lastConsonantIndex + 1]; // Character immediately following the last consonant in the current array state


             // Check if the last consonant is already followed by a mark or sequence part that prevents
             // adding another standard final mark (Sukun or END-OF-WORD Tanwin), EXCLUDING an intermediate Sukun.
             // This covers cases where the last consonant is followed by a vowel mark (َ,ِ,ُ,ٰ,ٖ), a sequence part (ا,و,ی,ٓ),
             // a Shadda (ّ), OR one of the Vowel+N/Ñ internal Tanwin alternatives (ً,ٌ,ٍ) OR one of the new 'a'/'á'/'iy' alternatives.
             // It EXCLUDES the intermediate Sukun (ْ) which we will remove if present.
            const isFollowedByNonSukunPreventingMark = isPreventingMarkOrExtender(charAfterLastConsonant) && charAfterLastConsonant !== 'ْ';

            if (isFollowedByNonSukunPreventingMark) {
                 console.log(`  Last consonant '${lastConsonant}' at index ${lastConsonantIndex} is followed by preventing mark '${charAfterLastConsonant}'. Skipping standard final consonant mark.`);
                 return resultChars.join(''); // Return array as is, final vocalization is already present.
            }

            // If we reach here, the last consonant is *not* followed by a non-Sukun preventing mark.
            // It might be followed by an intermediate Sukun. We need to remove it before adding the *correct* final mark.
             if (charAfterLastConsonant === 'ْ') {
                 resultChars.splice(lastConsonantIndex + 1, 1); // Remove the intermediate Sukun
                 console.log(`  Removed intermediate Sukun after last consonant '${lastConsonant}' at index ${lastConsonantIndex} before applying final mark.`);
             }
             // Note: len might have changed if Sukun was removed, but lastConsonantIndex is still relative to the start.


            // --- Check for single-consonant word exception (C V N/Ñ) ---
              let forceSukūn = false;
               // Check if the original Latin word is exactly 3 characters (C V N/Ñ pattern)
              const originalLen = latinWord.length;
              if (
                 originalLen === 3 &&
                 consonantsBase[latinWord[0]] !== undefined && // First char is a consonant
                 latinVowels.has(latinWord[1]) && // Second char is a vowel
                 (latinWord[2] === 'n' || latinWord[2] === 'ñ') // Third char is n or ñ
              ) {
                  // Check if the last consonant in the Arabic output is the one corresponding to n/ñ
                  // This logic is only reached if the internal Vowel+N/Ñ Tanwin rule *didn't* apply
                  // (because if it applied, the last char would be a Tanwin and caught by isFollowedByNonSukunPreventingMark).
                  // So, if we're here, the last consonant is indeed ن or ڭ from the CVn/ñ sequence.
                  if (lastConsonant === 'ن' || lastConsonant === 'ڭ') {
                       forceSukūn = true;
                       console.log(`  Detected single-letter C+V+N/Ñ pattern for Latin word '${latinWord}'. Forcing Sukūn on final consonant.`);
                  }
              }
              // --- End of C V N/Ñ Exception ---


             // --- Determine and apply the final mark (Sukūn or END-OF-WORD Tanwin) ---
             // This logic applies Sukun or Tanwin based on needsTanwin and lastSimpleVowelLatinChar
             const finalMarkInsertionIndex = lastConsonantIndex + 1;
             let finalMarkToInsert = null;

             if (forceSukūn || !needsTanwin) {
                 // Apply Sukūn
                 finalMarkToInsert = 'ْ';
                 console.log(`  Final mark determined: Sukūn ('ْ') (Forced: ${forceSukūn}, NeedsTanwin: ${needsTanwin}).`);

             } else { // needsTanwin is true AND not forcing Sukun (Word is last or before punctuation)
                 // Apply END-OF-WORD Tanwin alternative based on last simple vowel Latin character
                 let tanwinType = null;
                 if (lastSimpleVowelLatinChar !== null) {
                     tanwinType = latinVowelToTypeForTanwin[lastSimpleVowelLatinChar];
                 }

                 if (tanwinType && tanwinMap[tanwinType]) {
                     finalMarkToInsert = tanwinMap[tanwinType];
                     console.log(`  Final mark determined: END-OF-WORD Tanwin alternative '${finalMarkToInsert}' based on last simple vowel Latin char '${lastSimpleVowelLatinChar}' (type: ${tanwinType}).`);
                 } else {
                     // Fallback to standard Sukūn if no relevant vowel type found for final Tanwin
                     console.warn(`  No relevant last vowel Latin char ('${lastSimpleVowelLatinChar}') for final Tanwin alternative mapping. Final mark determined: standard Sukūn ('ْ').`);
                     finalMarkToInsert = 'ْ';
                 }
             }

             // Insert the determined final mark (if any) after the last consonant.
             if (finalMarkToInsert) {
                 resultChars.splice(finalMarkInsertionIndex, 0, finalMarkToInsert);
                 console.log(`  Applying final mark '${finalMarkToInsert}' after '${resultChars[lastConsonantIndex]}' at index ${lastConsonantIndex}. Final Array: ${resultChars.join('')}`);
             }

            return resultChars.join('');
        }


        // Main transliteration function
        function performTransliteration(latin) {
            console.log("Starting performTransliteration for:", latin);

            const segments = splitIntoWordsAndSeparators(latin); // Split into words and separators

             let finalArabicOutput = "";
             let pendingWordArabic = null; // Store Array of Arabic chars for the word before a separator (includes intermediate Sukuns and internal alternatives)
             let pendingWordLatin = null; // Store the original Latin word string (lowercase)
             let pendingWordVowelLatinChar = null; // Store the lastSimpleVowelLatinChar for the pending word


             for (let i = 0; i < segments.length; i++) {
                 const currentSegment = segments[i];
                 // A segment is a word if it's not empty and the first character is a Latin letter
                 const isCurrentSegmentWord = currentSegment.length > 0 && isLatinLetter(currentSegment[0]);
                 const isLastSegment = (i === segments.length - 1);

                 // If there is a pending word from the previous segment, process its final mark now
                 if (pendingWordArabic !== null) {
                      // Determine if the pending word should get the END-OF-WORD Tanwin vs Sukun
                      // It needs END-OF-WORD Tanwin IF the current segment is punctuation OR IF the current segment is the absolute last segment.
                      // Check if the current segment is a non-empty separator and maps to punctuation
                       const isCurrentSegmentPunctuation = (currentSegment !== null && currentSegment.length > 0 && punctuationSymbolsSet.has(currentSegment[0]));
                       const pendingWordNeedsTanwin = isCurrentSegmentPunctuation || isLastSegment;

                      console.log(`  Processing segment '${currentSegment}'. Applying final mark logic to pending word '${pendingWordLatin}'. IsCurrentSegmentPunctuation: ${isCurrentSegmentPunctuation}, IsLastSegment: ${isLastSegment}. Needs END-OF-WORD Tanwin: ${pendingWordNeedsTanwin}`);

                      // Apply final mark to the pending word (intermediate Sukuns and internal alternatives are already inside pendingWordArabic)
                      const wordWithFinalMark = applyFinalMarkToLastConsonant(pendingWordArabic, pendingWordLatin, pendingWordVowelLatinChar, pendingWordNeedsTanwin);
                      finalArabicOutput += wordWithFinalMark;

                      // Clear pending word
                      pendingWordArabic = null;
                      pendingWordLatin = null;
                      pendingWordVowelLatinChar = null;
                 }

                 if (isCurrentSegmentWord) {
                     // Transliterate the current word and store it as pending for the *next* iteration or end of loop.
                     // This transliteration step *includes* adding intermediate Sukuns and applying the 'a'/'á' and Vowel+N/Ñ internal randomization (when allowed).
                     const { arabicChars, lastSimpleVowelLatinChar: currentWordVowelLatinChar } = transliterateWord(currentSegment);
                     pendingWordArabic = arabicChars; // This array now contains intermediate Sukuns and randomized marks/alternatives
                     pendingWordLatin = currentSegment;
                     pendingWordVowelLatinChar = currentWordVowelLatinChar; // Store the Latin char

                      console.log(`  Current segment '${currentSegment}' is a word. Transliterated and storing as pending. PendingWordArabic count: ${pendingWordArabic.length}`);

                     // If this is the very last segment and it's a word, the pending word logic above won't run
                     // because there's no segment *after* it to trigger it. So handle this specific case now.
                     // This will apply the END-OF-WORD Tanwin directly to the last word.
                     if (isLastSegment) {
                          console.log(`  Current segment is the last segment and it's a word. Applying final mark logic to pending word now (needs END-OF-WORD Tanwin).`);
                          // The pending word *is* the last word. It needs Tanwin.
                           const wordWithFinalMark = applyFinalMarkToLastConsonant(pendingWordArabic, pendingWordLatin, pendingWordVowelLatinChar, true); // true -> gets END-OF-WORD Tanwin
                          finalArabicOutput += wordWithFinalMark;
                          // Clear pending
                          pendingWordArabic = null;
                          pendingWordLatin = null;
                          pendingWordVowelLatinChar = null;
                     }


                 } else { // Current segment is a separator
                     console.log(`  Current segment '${currentSegment}' is a separator. Adding to output.`);
                     // Add the separator itself (already handled the pending word if any)
                     // Map digits and symbols if necessary
                     let mappedSeparator = currentSegment;
                     if (currentSegment.length > 0) { // Ensure segment is not empty
                          const char = currentSegment[0]; // Take the first char for mapping
                           if (symbolMap[char]) {
                              mappedSeparator = symbolMap[char];
                           } else if (digitMap[char]) {
                                mappedSeparator = digitMap[char];
                           } else if (char === '\n') { // Keep newline character
                               mappedSeparator = '\n';
                           }
                           // If it was a single quote, it was already skipped in splitIntoWordsAndSeparators,
                           // so it won't appear here as a segment.
                           // If it's some other unmapped single character separator, it's added as is.
                     } else if (currentSegment === '\n') { // Handle potential multi-character newlines just in case, although split should handle them
                         mappedSeparator = '\n';
                     }
                     finalArabicOutput += mappedSeparator;
                 }
             } // End loop through segments


            console.log("Final combined Arabic string:", finalArabicOutput);
            return finalArabicOutput;
         }
    </script>

</body>
</html>
